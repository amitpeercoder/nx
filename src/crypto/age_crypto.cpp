#include "nx/crypto/age_crypto.hpp"

#include <fstream>
#include <random>
#include <sstream>
#include <regex>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "nx/util/safe_process.hpp"
#include "nx/util/security.hpp"

namespace nx::crypto {

namespace {
  /**
   * @brief Check if a string looks like age-encrypted content
   */
  bool looksLikeAgeContent(const std::string& content) {
    // Age files start with "-----BEGIN AGE ENCRYPTED FILE-----"
    return content.find("-----BEGIN AGE ENCRYPTED FILE-----") != std::string::npos;
  }

  /**
   * @brief Extract public key from age key file
   */
  Result<std::string> extractPublicKey(const std::filesystem::path& key_file) {
    std::ifstream file(key_file);
    if (!file) {
      return std::unexpected(makeError(ErrorCode::kFileError, 
                                       "Failed to read key file: " + key_file.string()));
    }
    
    std::string line;
    while (std::getline(file, line)) {
      if (line.find("# public key: ") == 0) {
        return line.substr(14); // Skip "# public key: "
      }
    }
    
    return std::unexpected(makeError(ErrorCode::kParseError, 
                                     "No public key found in key file"));
  }
}

AgeCrypto::AgeCrypto(std::filesystem::path key_file_path) 
  : key_file_path_(std::move(key_file_path)) {}

Result<AgeCrypto> AgeCrypto::initialize(const std::filesystem::path& key_file_path) {
  // Verify age tools are available
  auto tools_check = verifyAgeTools();
  if (!tools_check.has_value()) {
    return std::unexpected(tools_check.error());
  }
  
  // Check if key file exists and is readable
  if (!std::filesystem::exists(key_file_path)) {
    return std::unexpected(makeError(ErrorCode::kFileError, 
                                     "Key file does not exist: " + key_file_path.string()));
  }
  
  // Verify key file permissions (should be 0600)
  auto perms = std::filesystem::status(key_file_path).permissions();
  if ((perms & std::filesystem::perms::others_read) != std::filesystem::perms::none ||
      (perms & std::filesystem::perms::others_write) != std::filesystem::perms::none ||
      (perms & std::filesystem::perms::group_read) != std::filesystem::perms::none ||
      (perms & std::filesystem::perms::group_write) != std::filesystem::perms::none) {
    return std::unexpected(makeError(ErrorCode::kSecurityError,
                                     "Key file has insecure permissions. Should be 0600: " + key_file_path.string()));
  }
  
  return AgeCrypto(key_file_path);
}

Result<AgeCrypto::KeyInfo> AgeCrypto::generateKeyPair(
    const std::filesystem::path& key_file_path,
    const std::optional<std::string>& passphrase) {
  
  // Verify age tools are available
  auto tools_check = verifyAgeTools();
  if (!tools_check.has_value()) {
    return std::unexpected(tools_check.error());
  }
  
  // Generate key using age-keygen
  std::vector<std::string> args = {"-o", key_file_path.string()};
  
  auto result = nx::util::SafeProcess::execute("age-keygen", args);
  if (!result.has_value()) {
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "Failed to generate age key: " + result.error().message()));
  }
  
  if (!result->success()) {
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "age-keygen failed: " + result->stderr_output));
  }
  
  // Set secure permissions on key file
  std::filesystem::permissions(key_file_path, 
                              std::filesystem::perms::owner_read | std::filesystem::perms::owner_write,
                              std::filesystem::perm_options::replace);
  
  // Extract public key from generated file
  auto public_key_result = extractPublicKey(key_file_path);
  if (!public_key_result.has_value()) {
    return std::unexpected(public_key_result.error());
  }
  
  KeyInfo info;
  info.public_key = public_key_result.value();
  info.fingerprint = info.public_key.substr(0, 16); // First 16 chars as fingerprint
  info.comment = "Generated by nx notes";
  
  return info;
}

Result<AgeCrypto::KeyInfo> AgeCrypto::getKeyInfo() const {
  auto public_key_result = extractPublicKey(key_file_path_);
  if (!public_key_result.has_value()) {
    return std::unexpected(public_key_result.error());
  }
  
  KeyInfo info;
  info.public_key = public_key_result.value();
  info.fingerprint = info.public_key.substr(0, 16);
  info.comment = "nx notes encryption key";
  
  return info;
}

Result<std::string> AgeCrypto::encrypt(const std::string& content, const nx::core::NoteId& note_id) const {
  if (content.empty()) {
    return std::string{};
  }
  
  // Create secure temporary file for input
  auto temp_input_result = createSecureTempFile(content);
  if (!temp_input_result.has_value()) {
    return std::unexpected(temp_input_result.error());
  }
  
  // Create temporary file for output
  std::string temp_output = "/tmp/nx_encrypt_" + nx::util::Security::generateRandomString(16);
  
  // Encrypt using age
  std::vector<std::string> args = {
    "-r", key_file_path_.string(),
    "-o", temp_output,
    temp_input_result.value().string()
  };
  
  auto result = nx::util::SafeProcess::execute("age", args);
  
  // Clean up input file immediately
  std::filesystem::remove(temp_input_result.value());
  
  if (!result.has_value()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "Failed to encrypt content: " + result.error().message()));
  }
  
  if (!result->success()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "age encryption failed: " + result->stderr_output));
  }
  
  // Read encrypted output
  auto encrypted_result = readAndDeleteSecureTempFile(temp_output);
  if (!encrypted_result.has_value()) {
    return std::unexpected(encrypted_result.error());
  }
  
  return encrypted_result.value();
}

Result<std::string> AgeCrypto::decrypt(const std::string& encrypted_content, const nx::core::NoteId& note_id) const {
  if (encrypted_content.empty()) {
    return std::string{};
  }
  
  // Verify this looks like age content
  if (!looksLikeAgeContent(encrypted_content)) {
    return std::unexpected(makeError(ErrorCode::kParseError,
                                     "Content does not appear to be age-encrypted"));
  }
  
  // Create secure temporary file for encrypted input
  auto temp_input_result = createSecureTempFile(encrypted_content);
  if (!temp_input_result.has_value()) {
    return std::unexpected(temp_input_result.error());
  }
  
  // Create temporary file for output
  std::string temp_output = "/tmp/nx_decrypt_" + nx::util::Security::generateRandomString(16);
  
  // Decrypt using age
  std::vector<std::string> args = {
    "-d",
    "-i", key_file_path_.string(),
    "-o", temp_output,
    temp_input_result.value().string()
  };
  
  auto result = nx::util::SafeProcess::execute("age", args);
  
  // Clean up input file immediately
  std::filesystem::remove(temp_input_result.value());
  
  if (!result.has_value()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "Failed to decrypt content: " + result.error().message()));
  }
  
  if (!result->success()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "age decryption failed: " + result->stderr_output));
  }
  
  // Read decrypted output
  auto decrypted_result = readAndDeleteSecureTempFile(temp_output);
  if (!decrypted_result.has_value()) {
    return std::unexpected(decrypted_result.error());
  }
  
  return decrypted_result.value();
}

Result<void> AgeCrypto::encryptFile(const std::filesystem::path& file_path, const nx::core::NoteId& note_id) const {
  if (!std::filesystem::exists(file_path)) {
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "File does not exist: " + file_path.string()));
  }
  
  // Create temporary output file
  std::string temp_output = file_path.string() + ".tmp_" + nx::util::Security::generateRandomString(8);
  
  // Encrypt file
  std::vector<std::string> args = {
    "-r", key_file_path_.string(),
    "-o", temp_output,
    file_path.string()
  };
  
  auto result = nx::util::SafeProcess::execute("age", args);
  if (!result.has_value()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "Failed to encrypt file: " + result.error().message()));
  }
  
  if (!result->success()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "age file encryption failed: " + result->stderr_output));
  }
  
  // Atomically replace original with encrypted version
  try {
    std::filesystem::rename(temp_output, file_path);
  } catch (const std::exception& e) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "Failed to replace file with encrypted version: " + std::string(e.what())));
  }
  
  return {};
}

Result<void> AgeCrypto::decryptFile(const std::filesystem::path& file_path, const nx::core::NoteId& note_id) const {
  if (!std::filesystem::exists(file_path)) {
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "File does not exist: " + file_path.string()));
  }
  
  // Check if file is encrypted
  if (!isFileEncrypted(file_path)) {
    return std::unexpected(makeError(ErrorCode::kParseError,
                                     "File is not encrypted: " + file_path.string()));
  }
  
  // Create temporary output file
  std::string temp_output = file_path.string() + ".tmp_" + nx::util::Security::generateRandomString(8);
  
  // Decrypt file
  std::vector<std::string> args = {
    "-d",
    "-i", key_file_path_.string(),
    "-o", temp_output,
    file_path.string()
  };
  
  auto result = nx::util::SafeProcess::execute("age", args);
  if (!result.has_value()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "Failed to decrypt file: " + result.error().message()));
  }
  
  if (!result->success()) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "age file decryption failed: " + result->stderr_output));
  }
  
  // Atomically replace encrypted file with decrypted version
  try {
    std::filesystem::rename(temp_output, file_path);
  } catch (const std::exception& e) {
    std::filesystem::remove(temp_output);
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "Failed to replace file with decrypted version: " + std::string(e.what())));
  }
  
  return {};
}

bool AgeCrypto::isFileEncrypted(const std::filesystem::path& file_path) {
  std::ifstream file(file_path);
  if (!file) {
    return false;
  }
  
  std::string first_line;
  std::getline(file, first_line);
  
  return first_line.find("-----BEGIN AGE ENCRYPTED FILE-----") != std::string::npos;
}

bool AgeCrypto::isAvailable() {
  return nx::util::SafeProcess::commandExists("age") && 
         nx::util::SafeProcess::commandExists("age-keygen");
}

Result<void> AgeCrypto::verifyAgeTools() {
  if (!nx::util::SafeProcess::commandExists("age")) {
    return std::unexpected(makeError(ErrorCode::kNotFound,
                                     "age tool not found. Please install age/rage encryption tools."));
  }
  
  if (!nx::util::SafeProcess::commandExists("age-keygen")) {
    return std::unexpected(makeError(ErrorCode::kNotFound,
                                     "age-keygen tool not found. Please install age/rage encryption tools."));
  }
  
  // Test age version
  auto version_result = nx::util::SafeProcess::executeForOutput("age", {"--version"});
  if (!version_result.has_value()) {
    return std::unexpected(makeError(ErrorCode::kExternalToolError,
                                     "Failed to get age version: " + version_result.error().message()));
  }
  
  return {};
}

Result<std::filesystem::path> AgeCrypto::createSecureTempFile(const std::string& content) const {
  // Generate random filename
  std::string temp_name = "/tmp/nx_temp_" + nx::util::Security::generateRandomString(16);
  
  // Create file with secure permissions
  int fd = open(temp_name.c_str(), O_CREAT | O_WRONLY | O_EXCL, 0600);
  if (fd == -1) {
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "Failed to create secure temporary file: " + std::string(strerror(errno))));
  }
  
  // Write content
  ssize_t written = write(fd, content.data(), content.size());
  close(fd);
  
  if (written != static_cast<ssize_t>(content.size())) {
    std::filesystem::remove(temp_name);
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "Failed to write to temporary file"));
  }
  
  return std::filesystem::path(temp_name);
}

Result<std::string> AgeCrypto::readAndDeleteSecureTempFile(const std::filesystem::path& temp_path) const {
  std::ifstream file(temp_path, std::ios::binary);
  if (!file) {
    std::filesystem::remove(temp_path);
    return std::unexpected(makeError(ErrorCode::kFileError,
                                     "Failed to read temporary file: " + temp_path.string()));
  }
  
  std::string content((std::istreambuf_iterator<char>(file)), 
                      std::istreambuf_iterator<char>());
  file.close();
  
  // Securely delete temporary file
  std::filesystem::remove(temp_path);
  
  return content;
}

// EncryptionManager implementation

EncryptionManager::EncryptionManager(AgeCrypto crypto) : crypto_(std::move(crypto)) {}

Result<EncryptionManager> EncryptionManager::initialize(const std::filesystem::path& key_file) {
  auto crypto_result = AgeCrypto::initialize(key_file);
  if (!crypto_result.has_value()) {
    return std::unexpected(crypto_result.error());
  }
  
  return EncryptionManager(std::move(crypto_result.value()));
}

bool EncryptionManager::shouldEncrypt(const nx::core::NoteId& note_id) const {
  return encrypted_notes_.count(note_id.toString()) > 0;
}

Result<std::string> EncryptionManager::encryptIfNeeded(const std::string& content, const nx::core::NoteId& note_id) const {
  if (shouldEncrypt(note_id)) {
    return crypto_.encrypt(content, note_id);
  }
  return content;
}

Result<std::string> EncryptionManager::decryptIfNeeded(const std::string& content, const nx::core::NoteId& note_id) const {
  // Check if content is encrypted by looking for age header
  if (content.find("-----BEGIN AGE ENCRYPTED FILE-----") != std::string::npos) {
    return crypto_.decrypt(content, note_id);
  }
  return content;
}

Result<void> EncryptionManager::toggleNoteEncryption(const nx::core::NoteId& note_id, bool encrypt) {
  if (encrypt) {
    encrypted_notes_.insert(note_id.toString());
  } else {
    encrypted_notes_.erase(note_id.toString());
  }
  return {};
}

bool EncryptionManager::isNoteEncrypted(const nx::core::NoteId& note_id) const {
  return encrypted_notes_.count(note_id.toString()) > 0;
}

} // namespace nx::crypto